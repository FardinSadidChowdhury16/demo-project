# -*- coding: utf-8 -*-
"""330 practice for final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ga1bV97VgPzHJJh1cT2bsDFzwKYceym4
"""

import numpy as np
from numpy.polynomial import Polynomial
coeff=np.array([36,0,4,28,16,0,1])
eqn=Polynomial(coeff)
print(eqn)
#Ei obdhi equation create korlam
#ekhon jotobari boluk nah akno deriv korte parbo
f_1=eqn.deriv(1)
f_2=eqn.deriv(2)
f_3=eqn.deriv(3)
print(f_1)
print(f_2)
print(f_3)
#Ekhn jodi kono eqn eh x er man diye value ber korte bole
x=2
print(f_2(x))
#Jodi onek gulo deriv diye ekta eqn er val ber korte bole
Big_eqn=2*f_3(x)+3*f_2(x)-5*(x)
print(Big_eqn)
#jodi poly nomial create kore bivinno value diye man
#ber korte bole ex-(1,2,3,4)
test=np.array([1,2,3,4])
values=eqn(test)
print(values)

#Vandermond Matrix
def get_poly(data_x,data_y):
  count=len(data_x)
  matrix=np.zeros((count,count))
  for i in range (count):
    for j in range (count):
      matrix[i][j]=data_x[i]**j
  print(matrix)

  mat_inv=np.linalg.pinv(matrix)
  new=np.dot(mat_inv,data_y)
  p=Polynomial(new)
  return p

data_x = np.array([-5.,-3.,-1.,0.,3.,7.])
data_y = np.array([90.,-14.,-3.,1.,10.,42.])
p=get_poly(data_x,data_y)
print(p)
x_arr=np.linspace(-3,3,100)
test=p(x_arr)
print(test)

f = Polynomial([5, -2, 7, 0, 0, 0, 10])
# print(f)
x = 3
h = 1.5
f_1 = f.deriv(1)
#print(f_1)
# print(f_1)
def backward_difference(f, x, h):
    return (f(x) - f(x - h)) / h
def error(f, f_1, x, h):
    new_h = 0
    current_error = abs(f_1(x) - backward_difference(f, x, h))
    while current_error > 0.002463:
        h = h / 3
        current_error = abs(f_1(x) - backward_difference(f, x, h))
    new_h = h
    print(new_h)
    print(round(h,7))
    print(round(current_error,10))
x=error(f,f_1,x,h)

#Lagrange
class Lagrange_Polynomial:
    def __init__(self, data_x, data_y):
      self.data_x = data_x
      self.data_y = data_y
    def l(self, k, x):
        l_k = 1.0
        for i in range (len(self.data_x)): #range=self.degree+1
          if i!=k:
           l_k*=(x-self.data_x[i])/((self.data_x[k]-self.data_x[i]))
        return l_k
    def __call__(self, x_arr): #[5, 10, 44, 99, 77]
        p_x_arr  = np.zeros(len(x_arr))
        for i in range (len(self.data_x)):
          p_x_arr+=self.data_y[i]*self.l(i,x_arr)
        print(p_x_arr)
data_x = np.array([-3.5, -2.231, -1.152, -0.5, 0.198, 0.785, 1.6])
data_y = np.array([4.0, 1.193, 6.156, 2.0, 1.803, 2.558, 0.0])
p = Lagrange_Polynomial(data_x, data_y)
val=p(2)
print(val,"Fardin")
print(p)

#newton
difference = lambda y2, y1, x2, x1: (y2-y1)/(x2-x1)

def calc_div_diff(x,y):
    assert(len(x)==len(y))
    n = len(x)
    b = np.zeros((n,n))
    b[:,0] = y
    for c in range(1,n):
      for r in range(n-c):
        b[r][c] = difference(b[r+1][c-1],b[r][c-1],x[r+c],x[r])
    return b[0]

class Newtons_Divided_Differences:

    def __init__(self, differences, data_x):
        self.differences = differences
        self.data_x = data_x

    def n(self, k, x):
        result = 1
        for i in range(k):
            result *= (x - self.data_x[i])
        return result

    def __call__(self, x):
        res = np.zeros(len(x))
        for i in range(len(x)):
          for j in range(len(self.data_x)):
              res[i] += self.differences[j]*self.n(j,x[i])
        return res

data_x = np.array([-3., -2., -1., 0., 1., 3.])
data_y = np.array([-80., -13., 6., 1., 5., 16.])
p = get_poly(data_x, data_y)
print(p)


x_arr = np.linspace(-3, 3, 100)
test = p(x_arr)
print(test)

#newton
difference = lambda y2, y1, x2, x1: (y2-y1)/(x2-x1)

def calc_div_diff(x,y):
    assert(len(x)==len(y))
    n = len(x)
    b = np.zeros((n,n))
    b[:,0] = y
    for c in range(1,n):
      for r in range(n-c):
        b[r][c] = difference(b[r+1][c-1],b[r][c-1],x[r+c],x[r])
    return b[0]

class Newtons_Divided_Differences:

    def __init__(self, differences, data_x):
        self.differences = differences
        self.data_x = data_x

    def n(self, k, x):
        result = 1
        for i in range(k):
            result *= (x - self.data_x[i])
        return result

    def __call__(self, x):
        res = np.zeros(len(x))
        for i in range(len(x)):
          for j in range(len(self.data_x)):
              res[i] += self.differences[j]*self.n(j,x[i])
        return res

data_x = np.array([-3., -2., -1., 0., 1., 3.])
data_y = np.array([-80., -13., 6., 1., 5., 16.])
p = get_poly(data_x, data_y)
print(p)


x_arr = np.linspace(-3, 3, 100)
test = p(x_arr)
print(test)